# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `deep_dup` gem.
# Please instead update this file by running `bin/tapioca gem deep_dup`.

# Deep duplicate any object. Some objects cannot be +dup+ped like +nil+,
# +false+, +true+, numbers, symbols and method objects. In those cases
# return themselves.
#
# @example No monkey patching
#   dupped = DeepDup.deep_dup('chunky')
#   dupped = DeepDup.deep_dup(['chunky', [:bacon, { hi: 5 }]])
#   dupped = DeepDup.deep_dup(['a', :a, 1, { bacon: { chunky: 'yeah' } }])
#   dupped = DeepDup.deep_dup(SomeClass.new)
#
#   array = [1, 2]
#   array << array
#   dupped = DeepDup.deep_dup(array)
# @example With monkey patching
#   require 'deep_dup/core_ext/object'
#
#   dupped = 'chunky'.deep_dup
#   dupped = ['chunky', [:bacon, { hi: 5 }]].deep_dup
#   dupped = ['a', :a, 1, { bacon: { chunky: 'yeah' } }].deep_dup
#   dupped = SomeClass.new.deep_dup
#
#   array = [1, 2]
#   array << array
#   dupped = array.deep_dup
#
# source://deep_dup//lib/deep_dup/version.rb#1
module DeepDup
  class << self
    # Prevent infinite recursion on recursive data structures.
    #
    # Imagine an array that has only one item which is a reference to itself.
    # When entering this method, the cache is empty so we create a new array
    # and map the original object's id to this newly created object.
    #
    # We then give control back to +deep_dup+ so that it can go on and do the
    # adding, which will call itself with the same array and enter this method
    # again.
    #
    # But this time, since the object is the same, we know the duplicate object
    # because we stored in in our little cache. So just go ahead and return it
    # otherwise it would result in an infinite recursion.
    #
    # @param object [Array, Hash] Original object reference.
    # @param new_object [Array, Hash] The dupped object reference.
    # @param cache [Hash] Map from original object_id to dupped object.
    # @return [Array, Hash] The dupped object.
    # @yieldparam new_object [Array, Hash] The dupped object reference.
    #
    # source://deep_dup//lib/deep_dup.rb#90
    def cache_object(object, new_object, cache); end

    # Deep duplicate any object.
    #
    # @example
    #   dupped = DeepDup.deep_dup('chunky')
    #   dupped = DeepDup.deep_dup(['chunky', [:bacon, { hi: 5 }]])
    #   dupped = DeepDup.deep_dup(['a', :a, 1, { bacon: { chunky: 'yeah' } }])
    #   dupped = DeepDup.deep_dup(SomeClass.new)
    #
    #   array = [1, 2]
    #   array << array
    #   dupped = DeepDup.deep_dup(array)
    # @param object [Object] Pretty much anything.
    # @param cache [Hash] Cache +object_id+s to prevent stack overflow on
    #   recursive data structures.
    # @return [Object] Dupped object if possible.
    #
    # source://deep_dup//lib/deep_dup.rb#46
    def deep_dup(object, cache = T.unsafe(nil)); end
  end
end

# Version number, happy now?
#
# source://deep_dup//lib/deep_dup/version.rb#3
DeepDup::VERSION = T.let(T.unsafe(nil), String)
